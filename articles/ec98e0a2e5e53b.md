---
title: "DockerビギナーによるDocker環境構築 for Windows"
emoji: "👻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["docker", "windows", "wsl"]
published: false
---

# Docker環境構築

## Windowsターミナルインストール

Windowsターミナルを[Microsoft Store](https://aka.ms/terminal)からインストールする。

![install-windows-terminal.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-windows-terminal.png)

## Gitインストール

Gitインストーラを[https://git-scm.com/download/win](https://git-scm.com/download/win)からダウンロードし実行する。  
実行したらライセンスの内容に同意し次へ進む。

![install-git-1.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-git-1.png)

インストールするコンポーネントの選択で、何も変更せず次へ進む。

![install-git-2.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-git-2.png)

新しいリポジトリの最初のブランチ名を設定する。  
GitHubの仕様に合わせてmainに変更し次へ進む。

![install-git-3.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-git-3.png)

Gitに接続する際に認証補助を使用するかどうかを設定する。  
[Git Credential Manager Core]を選択し次へ進む。  
※[Git Credential Manager Core]は、GitHub等と接続した時の2回目以降のユーザー名とパスワードをの入力を省略する。

![install-git-4.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-git-4.png)

追加オプションの設定。  
何も選択せずインストールへ進む。

![install-git-5.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-git-5.png)

GitBashを開き、Gitのバージョンを確認。

```sh
$ git --version;
git version 2.32.0.windows.1
```

以上で、Gitのインストールは完了。

## WSL2有効化

PowerShellを開き、以下コマンドを実行し管理者としてPowerShellを開く。

```sh
$ Start-Process powershell.exe -Verb runas;
```

Linux用Windowsサブシステムオプション機能を有効にする。

```sh
$ dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart;
```

仮想マシンプラットフォームオプション機能を有効にする。

```sh
$ dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart;
```

マシンを再起動し、Linuxカーネル更新プログラムパッケージを[ここ](https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi)からダウンロードし実行する。

![enable-wsl2-1.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/enable-wsl2-1.png)

一般ユーザで、PowerShellを開き新しいLinuxディストリビューションをインストールした際の既定のバージョンにWSL2を設定する。

```sh
$ wsl --set-default-version 2;
```

Microsoft Storeを開き、[ここ](https://www.microsoft.com/store/apps/9n6svws3rx71)から、Ubuntu 20.04 LTSディストリビューションをインストール。

![enable-wsl2-2.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/enable-wsl2-2.png)

新しくインストールしたLinuxディストリビューションを初めて起動すると、コンソールウィンドウが開くので、新しいLinuxディストリビューションのユーザーアカウントとパスワードを作成。  

```sh
Installing, this may take a few minutes...
Please create a default UNIX user account. The username does not need to match your Windows username.
For more information visit: https://aka.ms/wslusers
Enter new UNIX username: takuya-motoshima
New password:
Retype new password:
passwd: password updated successfully
Installation successful!
```

以上で、WindowsOSと完全に統合されたLinuxディストリビューションのインストールと設定は完了。

## Dockerインストール

[https://www.docker.com/](https://www.docker.com/)を開き、[Get started]を選択し、DockerDesktopのダウンロードページを開く。

![install-docker-1.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-docker-1.png)

\[Docker Desktop\]の\[Download for Windows\]を選択し、DockerDesktopをダウンロードする。

![install-docker-2.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-docker-2.png)

ダウンロードしたDocker Desktop Installer.exeを実行し、インストールを進める。  
OSのバージョンがWSL2に対応している場合、デフォルト状態でWSL2のコンポーネントがインストールされる。  
\[Install required Windows components for WSL 2\]が、チェックされていることを確認し、次へ進む。

![install-docker-3.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-docker-3.png)

インストールが完了したらDockerDesktopを起動する。

![install-docker-4.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-docker-4.png)

Dockerが起動したら、\[Skip tutorial\]を選択しチュートリアルをスキップして、次へ進む。

![install-docker-5.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-docker-5.png)

\[Settings – Resources – WSL INTEGRATION\]を開き\[Utuntu-20.04\]にチェックをし、  
Utuntu-20.04をデフォルトのWSLディストリビューションとして設定し、  
WSL2に構築したUtuntu-20.04上でDockerコマンドの使用を行えるようにする。

![install-docker-6.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/install-docker-6.png)

以上で、Dockerの環境構築は完了。

# 公式のhello-worldで基本的な仕組みを理解する

WindowsTerminalを開き、WSL2に構築したUtuntu-20.04に接続する。

![install-docker-6.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/hellorworld-1.png)

まずはdocker runコマンドで、公式のhello-worldのイメージを取得、コンテナの実行をしてみる。  
コンテナとはアプリやインフラなどを入れた箱であり、イメージとはコンテナを実行するために必要なファイルシステムのことである。

```sh
$ docker container run hello-world;
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
b8dfde127a29: Pull complete
Digest: sha256:9f6ad537c5132bcce57f7a0a20e317228d382c3cd61edae14650eec68b2b345c
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
```

hello-worldコンテナを実行することができた。  
メッセージにはコマンド実行後に起こったことの説明が書かれている。

```sh
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
b8dfde127a29: Pull complete
Digest: sha256:9f6ad537c5132bcce57f7a0a20e317228d382c3cd61edae14650eec68b2b345c
Status: Downloaded newer image for hello-world:latest
```

上記は、初めてイメージを取得する場合表示されるメッセージである。
簡単に解説すると、  

- ローカルにhello-world:latestが存在しないためDocker Hubよりイメージを取得
- イメージをsha256でハッシュ化
- hello-wolrd:latestがダウンロードされたことを表している

後ろに存在するlatestはタグで、コマンドをタグ指定なしで実行した場合、タグは自動的にlatestが選択される。  

現在のイメージとコンテナを確認してみる。  

```sh
$ docker image ls;
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
hello-world   latest    d1165f221234   4 months ago   13.3kB
```

latestタグを持ったhello-worldイメージが確認できた。  
起動中のコンテナを確認してみる。

```sh
$ docker container ls;
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```

何も存在しない。  
hello-worldコンテナはメッセージ出力が終わるとコンテナを停止してしまうため、起動していない。
-a オプションを付け、停止中のコンテナも表示して見る。

```sh
$ docker container ls -a;
CONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS     NAMES
ce078f901c88   hello-world   "/hello"   8 minutes ago   Exited (0) 8 minutes ago             quirky_haibt
```

これでhello-worldイメージとコンテナを確認できた。  
最後にこれらを削除して、公式のhello-worldコンテナの確認を終える。

```sh
# コンテナを削除。docker container ls -aコマンドで確認したコンテナIDを指定。
$ docker container rm ce078f901c88;
ce078f901c88

# イメージを削除。docker image lsコマンドで確認したイメージIDを指定。
$ docker image rm d1165f221234;
Untagged: hello-world:latest
Untagged: hello-world@sha256:df5f5184104426b65967e016ff2ac0bfcd44ad7899ca3bbcf8e44e4461491a9e
Deleted: sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726
Deleted: sha256:f22b99068db93900abe17f7f5e09ec775c2826ecfe9db961fea68293744144bd
```

docker container rm <コンテナID>でコンテナの削除、  
docker image rm <イメージID>でイメージの削除を行った。  
以上で、公式のhello-worldコンテナの確認は完了。

# Hello Worldアプリケーション作成

Hello Worldを表示するWEBアプリケーションのイメージの作成からコンテナの実行までを行いDockerの使い方を学ぶ。  
今回はWEBアプリケーションの言語はNode.js、フレームワークにExpressを使用する。  
以下の流れでコンテナを作成・実行していく。

![hellorworld-2.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/hellorworld-2.png)

## 最新のNode.jsをインストール

Node.jsでアプリケーションを作成する上で最新のNode.jsを使用したい。  
DockerホストにnというNode.jsのバージョン管理パッケージをインストールし、nパッケージで最新のNode.jsとnpmをインストールする。  
まずパッケージを更新する。

```sh
$ sudo apt update;
$ sudo apt upgrade
```

Node.jsとnpmをインストールする。

```sh
$ sudo apt install nodejs npm;
```

nパッケージをインストールする。

```sh
$ sudo npm -g install n;
```

最新バージョンのNode.jsとnpmをインストールする。

```sh
$ sudo n latest;
```

既存のNode.jsとnpmをアンインストールする。

```sh
$ sudo apt purge nodejs npm;
```

Node.jsとnpmの更新を反映させる為に再ログインする。

```sh
$ exec $SHELL -l;
```

Node.jsとnpmのバージョンを確認する。

```sh
$ node -v;
v16.4.1

$ npm -v;
7.18.1
```

以上で、最新のNode.jsがインストールされた。

## Node.jsアプリケーションを作成する

では進めていく。  
Dockerホストに作業ディレクトリを作成する。

```sh
$ mkdir ~/my-docker;
$ cd  ~/my-docker/;
```

Dockerホストの作業ディレクトリで、 package.jsonファイルを作成し依存関係をインストールする。

```sh
$ npm init -y && npm i express;
```

Expressフレームワークを使ってHello Worldを表示するWEBアプリケーションをserver.jsに作成する。

```js:server.js
const express = require('express');

// Constants
const PORT = 8080;
const HOST = '0.0.0.0';

// App
const app = express();
app.get('/', (req, res) => {
  res.send('Hello World');
});

app.listen(PORT, HOST);
```

## Dockerfile作成

Dockerfileとは、Docker上で動作させるコンテナの構成情報を記述するためのファイル。  
イメージの雛形であり、ベースイメージ、ライブラリのインストール等の追加処理、アプリケーションコードの定義等を記述しDockerイメージの基となる。

![hellorworld-3.png](https://raw.githubusercontent.com/takuya-motoshima/zenn-content/main/articles/ec98e0a2e5e53b/hellorworld-3.png)

以下のDockerfileを作成する。

```dockerfile:Dockerfile
FROM node:16

# アプリケーションディレクトリを作成する
WORKDIR /var/www

# アプリケーションの依存関係をインストールする
COPY package*.json ./
RUN npm install

# アプリケーションコードをバンドルする
COPY . .

# 外部に公開するポートを指定
EXPOSE 8080
CMD ["node", "server.js"]
```

Dockerfileに定義した命令を詳しく解説していく。

- FROM node:16

    ベースとなるイメージを指定する。  
    今回は、DockerHubから入手できるNode.js 16のイメージを使用する。  
    ※このイメージにはNode.jsとnpmが既にインストールされている為、改めてインストールする必要はない。

- WORKDIR /var/www

    アプリケーションコードを置くイメージ上の作業ディレクトリを指定する。  
    イメージに作業ディレクトリが存在しない場合は、自動で生成される。

- COPY package*.json ./
- RUN npm install

    Dockerホストの作業ディレクトリにあるpackage.jsonとpackage-lock.jsonをイメージの作業ディレクトリにコピーし、npm installでアプリケーションの依存関係をインストールする。  
    依存関係のインストールと、アプリケーションコードのバンドルを分けている理由は、Dockerビルドをする際、Dockerfileで実行済みのコマンドはキャッシュが使用される。  
    ただし、ADDやCOPYコマンドでビルド媒体などをコンテナにコピーする際、コピー元のファイルに変更があった場合は、キャッシュは使用されず、新しい媒体がコンテナ内にコピーされ、それ以降の命令ではキャッシュは使用されなくなる。  
    そのため、変更が少ない依存関係のインストールをDockerfileの最初の方で行うことで、依存関係のインストールに変更がない限りは2回目以降の依存関係のインストールはキャッシュが使用されDockerビルドの時間が短縮できる。  

- COPY . .

    DockerホストにあるアプリケーションのソースコードをDockerイメージにバンドルする。

- EXPOSE 8080

    WEBアプリケーションがLISTENするポートを指定する。  
    EXPOSE命令は実際にはポートを公開する訳ではなく、どのポートが公開されるかという情報を明示するだけである点に注意する。  
    実行したコンテナのポートを実際に公開するには、docker container runで-pオプションを使用してDockerホストとコンテナのポートをマッピングする。

- CMD \["node", "server.js"\]

    WEBアプリケーションを実行するコマンドを定義する。

## .dockerignoreファイル作成

Dockerホストからイメージにディレクトリやファイルを送る際に、イメージに送りたくないディレクトリやファイルを.dockerignoreに定義できる。  

今回は誤ってDockerホストにある依存パッケージがイメージ内にインストールされているパッケージに上書きされてしまう事態を防ぎいため、node_modulesを設定する。

```text:.dockerignore
node_modules
```

## イメージを構築

Dockerfileがあるディレクトリに移動し、次のコマンドを実行してDockerイメージを構築する。  

- -t イメージ名[:タグ]: 名前とオプションのタグを指定する。  
    名前を付けた方が名前からイメージの操作を行え作業効率が良いのと、またイメージを管理しやすいので名前を付けておく。

```sh
docker image build -t my-docker .;
```
